---
title: "irrigation comparison"
author: "Anna Boser"
date: '2022-05-04'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(stringr)
library(sf)
library(data.table)
library(tidyr)
library(dplyr)
library(latex2exp)
library(ggplot2)
library(lfe)
library(rgdal)
library(ggnewscale) # allows you to plot multiple things with different scales on one ggplot

source(here("file_paths.R"))
source(here("helper_functions.R"))
```


## Read in the data
```{r}
experiment_name <- "fallow_3-9_gb"
experiment_path <- here("data", "4_for_analysis", "ML_outputs",  "experiments", experiment_name)
ET_year <- NA
irr_year <- NA
```

```{r}
data <- fread(file = here(experiment_path, "agriculture_yearly.csv"))

data <- data[cropnames != "Urban - residential, commercial, and industrial, unsegregated",] # remove urban
data$cropnames <- ifelse(data$cropnames %in% c("Unclassified fallow", "Idle"), "Fallow", data$cropnames) # rename unclassified
data <- filter(data, cropnames != "Fallow")

# average over years/select your year of choice
if (!is.na(ET_year)){
  data <- filter(data, year == ET_year)
} else {
  data <- data %>% group_by(x, y, NAME, Soil) %>% summarize(ag_ET = mean(ag_ET), 
                                                      PET = mean(PET), 
                                                      ET_pred = mean(ET_pred), 
                                                      ET = mean(ET))
}
```

Assign a cluster to get the proper standard errors
```{r}
# create clusters based on location. Function creates clusters of size dist km. 
data$cluster <- mapply(assign_cluster, data$x, data$y, 75)
```

I then need to get the total water ETd
Since it's in mm/month, I need to multiply by the number of months
```{r}
data$ag_ET_year <- data$ag_ET*12
```

Use a clustered standard errors regression to retrieve the water consumption by county
```{r}
# get confidence intervals using clustered standard errors
ag_ET <- felm(ag_ET_year~NAME-1 | 0 | 0 | cluster, data) #+year

# extract the mean and ci values from each
df_from_felm <- function(input_lm){
  ET_df <- as.data.frame(cbind(input_lm$coefficients, input_lm$cse))
  colnames(ET_df) <- c("ag_ET_mm_year", "ag_ET_se")
  ET_df$ag_ET_min <- ET_df$ag_ET_mm_year-(2*ET_df$ag_ET_se)
  ET_df$ag_ET_max <- ET_df$ag_ET_mm_year+(2*ET_df$ag_ET_se)
  ET_df$NAME <- substring(rownames(ET_df), 5)
  return(ET_df)
}

ET_df <- df_from_felm(ag_ET)
```


Add back in some more information about the counties
```{r}
# average over county
county_avg <- data %>%
  group_by(NAME) %>% # group by county here
  summarize(
    lon = mean(x, na.rm=TRUE),
    lat = mean(y, na.rm=TRUE),
    soil = mean(Soil, na.rm=TRUE),
    ET = mean(ET, na.rm=TRUE), # all these are mm/day
    ET_pred = mean(ET_pred, na.rm=TRUE),
    ag_ET = mean(ag_ET, na.rm=TRUE),
    PET = mean(PET, na.rm=TRUE),
    ET_pred = mean(ET_pred, na.rm=TRUE),
    n = n()) #get the number of pixels in each county

# add other information about the counties back in 
ET_df <- merge(ET_df, county_avg, by = "NAME")
```


## USGS Irrigation data

### Read in USGS data. Make a single irrigation dataset with 2010 and 2015 data
```{r}
irrigation2015 <- read.csv(here(usgs_irr_path,
                       "2015",
                       "water_use"), sep = "\t")[-1,] #first row just tells you the size of the entries; remove

irrigation2010 <- read.csv(here(usgs_irr_path,
                       "2010",
                       "water_use"), sep = "\t")[-1,] #first row just tells you the size of the entries; remove

irrigation2015$year <- 2015
irrigation2010$year <- 2010

irrigation <- rbind(irrigation2015, irrigation2010)

rm(irrigation2010)
rm(irrigation2015)
```

### Clean USGS irrigation data
Change units to kg/day and meters squared
```{r}
irrigation$NAME <- str_remove(irrigation$county_nm, " County") # remove the "County" suffix to each county name in order to match to county shapefile names


# convert billions of gallons per day to kg per day
conversion <- function(Mgal.d){
  Mgal.d = as.numeric(Mgal.d)
  kg.d = Mgal.d * 3.785411784 * 1000000
}

to_convert = names(irrigation)[c(6:10, 15)] #the names of the columns that are in Mgal/d and need to be converted
irrigation <- mutate(irrigation, across(to_convert, conversion))


# convert thousands of acres to square meters
conversion <- function(tacre){
  tacre = as.numeric(tacre)
  m2 = tacre * 1000 * 4046.86 # conversion to acres and conversion to square meters
}

to_convert = names(irrigation)[c(11:14)] #the names of the columns that are in thousand of acres and need to be converted

irrigation <- mutate(irrigation, across(to_convert, conversion))

# add a mm/day and mm/year variable
# keep in mind the column names no longer reflect the true units
irrigation$mm.day <- irrigation$Irrigation..Crop.total.self.supplied.withdrawals.for.crops..fresh..in.Mgal.d/irrigation$Irrigation..Crop.total.irrigation.for.crops..in.thousand.acres

irrigation$mm.year <- irrigation$mm.day*365

# also get the percent drip and flood irrigation for each county
irrigation$drip <- irrigation$Irrigation..Crop.microirrigation.for.crops..in.thousand.acres/irrigation$Irrigation..Crop.total.irrigation.for.crops..in.thousand.acres
irrigation$flood <- irrigation$Irrigation..Crop.surface.irrigation.for.crops..in.thousand.acres/irrigation$Irrigation..Crop.total.irrigation.for.crops..in.thousand.acres
irrigation$sprinkler <- irrigation$Irrigation..Crop.sprinkler.irrigation.for.crops..in.thousand.acres/irrigation$Irrigation..Crop.total.irrigation.for.crops..in.thousand.acres
```


```{r}

if (is.na(irr_year)){
  # take the average irrigation over different years to simplify
  irrigation_avg <- irrigation %>% 
  group_by(NAME) %>% 
  summarize(mm.year = mean(mm.year),
            mm.day = mean(mm.day),
            flood = mean(flood), 
            drip = mean(drip), 
            sprinkler = mean(sprinkler))
} else {
  # or just use one year
irrigation_avg <- irrigation %>% filter(year == irr_year)
irrigation_avg$year <- NULL
}

```

```{r}
# merge ET and irrigation datasets to get the irrigation efficiency
efficiency_df <- base::merge(irrigation_avg, ET_df, by="NAME", all.x = TRUE)
efficiency_df$irrigation_efficiency <- efficiency_df$ag_ET_mm_year*100/efficiency_df$mm.year
efficiency_df$irrigation_efficiency_min <- efficiency_df$ag_ET_min*100/efficiency_df$mm.year
efficiency_df$irrigation_efficiency_max <- efficiency_df$ag_ET_max*100/efficiency_df$mm.year
```

## Do some plotting!

### Read in county shapefile and merge dfs
```{r}
# study area and counties
study_area <- st_read(study_area_loc) %>% st_transform(st_crs("+proj=longlat +datum=WGS84"))
counties <- st_read(counties_loc) %>% filter(STATEFP == "06") %>% st_transform(st_crs("+proj=longlat +datum=WGS84"))
counties_irrigation <- base::merge(counties, efficiency_df, by = "NAME")
```


### Plot 1: irrigation use and agricultural water consumption
```{r, eval = FALSE}
ggplot() + 
  geom_sf(data = counties_irrigation, aes(fill = mm.year/10), color=alpha("red",0)) + 
  scale_fill_gradient2(name="Irrigation (cm/year)", low = "red", mid = "white", high = "deepskyblue4") + 
  # geom_sf(data = counties_irrigation, fill=alpha("red",0), color=alpha("grey64")) + 
  geom_sf(data = study_area, fill=alpha("red",0), color = "black", size = .2) + 
  new_scale_fill() +
  geom_raster(data = data[sample(nrow(data), size = nrow(data), replace = FALSE),], aes(x=x, y=y, fill=ag_ET_year/10), alpha=0.75) +
  scale_fill_gradientn(name="Agricultural water consumption (cm/year)", colours = c("darkgoldenrod2", "khaki1", "lightgreen",  "deepskyblue","mediumblue", "navyblue", "midnightblue", "black"), limits = c(-39.1, 234.6)) +
  theme_void() + 
  xlim(c(minlong, maxlong)) + 
  ylim(c(minlat, maxlat)) + 
  theme(legend.position = c(.8, .82), 
        legend.direction = "horizontal", 
        legend.title = element_blank(), 
        legend.margin = margin(18))
```

### Plot 2: irrigation use and agricultural water consumption in the central valley
```{r}
# remove counties that don't have any CV agriculture
cv_data <- counties_irrigation
cv_data <- filter(counties_irrigation, n > 50000)

ggplot() + 
  geom_sf(data = counties, fill = "grey", color=alpha("white",1), size = .2) + 
  geom_sf(data = cv_data, aes(fill = irrigation_efficiency), color=alpha("black",.2), size = .2) + 
  geom_text(data = cv_data, aes(x = lon, y = lat, label = round(irrigation_efficiency, 0)), size = 2) + 
  scale_fill_gradient2(name = "Irrigation efficiency (%)", low = "red", mid = "white", high = "#70AD47", limits = c(0, max(cv_data$irrigation_efficiency))) + 
  geom_sf(data = study_area, fill=alpha("red",0), color = "black", size = .2) + 
  xlim(c(minlong, maxlong)) + 
  ylim(c(minlat, maxlat)) + 
  theme_void() + 
  theme(legend.position = c(.87, .84)) 
```


# Compare predictions to what the data returned
```{r}
efficiency_calc <- function(flood, drip){
  sprinkler = 1-flood-drip
  
  # conveyance efficiency
  CE = .90 # theoretically depends on type of conveyance technology
  
  # distribution/management efficiency
  DE = .95 
  
  # application efficiency
  AE = (drip*.95) + (sprinkler*.75) + (flood*.60)
  
  return(CE*DE*AE*100)
}

counties_irrigation$theoretical_efficiency <- efficiency_calc(counties_irrigation$flood,  counties_irrigation$drip)
```

```{r}
# plot
counties_irrigation <-  filter(counties_irrigation, n > 50000)
counties_irrigation %>%
  ggplot() + 
  geom_smooth(aes(x = theoretical_efficiency, y = irrigation_efficiency), method = lm) + 
   geom_linerange(aes(x = theoretical_efficiency, ymin = irrigation_efficiency_min, ymax = irrigation_efficiency_max)) + 
  geom_abline(intercept=0,slope=1, color="grey") + 
  geom_point(aes(x = theoretical_efficiency, y = irrigation_efficiency, color=lat), size = 2) +
  scale_color_distiller(palette="RdYlBu", direction=1, name = "Latitude") + 
  theme_dark() + 
  xlab("Theoretical irrigation efficiency (%)") + 
  ylab("Empirical irrigation efficiency (%)") 
```

```{r, eval = FALSE}
summary(lm(data = counties_irrigation, irrigation_efficiency~theoretical_efficiency))
summary(lm(data = counties_irrigation, irrigation_efficiency~theoretical_efficiency+lat))
summary(lm(data = counties_irrigation, irrigation_efficiency~flood+drip+PET+sprinkler-1))
summary(lm(data = counties_irrigation, irrigation_efficiency~flood+drip+ET_pred+sprinkler-1))
summary(lm(data = counties_irrigation, irrigation_efficiency~flood+drip+PET+ET_pred+sprinkler-1))
summary(lm(data = counties_irrigation, irrigation_efficiency~flood+drip+sprinkler-1))
summary(lm(data = counties_irrigation, irrigation_efficiency~(flood+drip+sprinkler)*ET_pred-1))
```


```{r}
# average drip irrigated by county
mean(filter(counties_irrigation, n > 50000)$drip, na.rm = TRUE)
mean(filter(counties_irrigation, n > 50000)$flood, na.rm = TRUE)
```

## Statsitics: overall efficiency + CIs
```{r}
# In order to get confidence intervals for the overall numbers I will need the entire dataset
data_irr <- merge(data, irrigation_avg, by = "NAME", all.x = TRUE, all.y = FALSE)
data_irr$irrigation_efficiency <- data_irr$ag_ET_year*100/data_irr$mm.year

# get confidence intervals using clustered standard errors
total_eff <- felm(irrigation_efficiency~1 | 0 | 0 | cluster, data_irr) #+year

# extract the mean and ci values from each
df_from_felm <- function(input_lm){
  ET_df <- as.data.frame(cbind(input_lm$coefficients, input_lm$cse))
  colnames(ET_df) <- c("mean", "se")
  ET_df$min <- ET_df$mean-(2*ET_df$se)
  ET_df$max <- ET_df$mean+(2*ET_df$se)
  ET_df$NAME <- substring(rownames(ET_df), 5)
  return(ET_df)
}

total_eff_df <- df_from_felm(total_eff)

print("total_eff_df")
print(total_eff_df)
```
